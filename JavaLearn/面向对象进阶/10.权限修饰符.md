#Java/Java基础/面向对象 
==是用来控制一个成员能够被访问的范围的==

可以修饰：成员变量、方法、构造方法、内部类
# 权限修饰符
## 分类
作用范围由小到大（private<空着不写(缺省/默认)<protected<public）
![image.png](https://pic.hibugs.net/NGBTEAM/20250326152625346.png)
## 使用规则
实际开发中，一般只用private和public
- 成员变量私有
- 方法公开
**特例**：如果方法中的代码是抽取其他方法中共性代码，这个方法一般私有
# 代码块
两个大括号包裹的就是代码块
![image.png](https://pic.hibugs.net/NGBTEAM/20250326154350145.png)
## 分类
### 局部代码块（渐渐消失，了解即可）
局部指的是在方法里面，代码块就是用大括号包裹的

例如，正常的代码应如下
![image.png](https://pic.hibugs.net/NGBTEAM/20250326154533056.png)

但当我们使用大括号进行包裹之后，这一块被大括号包裹的就是代码块，并且他在方法里面所以就是**局部代码块**
![image.png](https://pic.hibugs.net/NGBTEAM/20250326154641175.png)
#### 作用
提前结束变量的生命周期，就是为了节省内存空间，比如上图的`int a = 10;`如果你打印完之后并不会用到a了，那么就可以使用局部代码块的形式包裹他，让他在这个局部代码块运行完之后就在内存中消失，从而节省内存空间，但是在计算机硬件发达的现在运用的较少
### 构造代码块（渐渐淘汰了，不够灵活）
写在成员位置的代码块

将构造方法中重复的代码写在成员变量的位置，用大括号包裹，这样就会先于构造方法执行
![image.png](https://pic.hibugs.net/NGBTEAM/20250326155337282.png)
可以将其改写成如下，这样这重复的语句就会在构造方法运行前，运行
![image.png](https://pic.hibugs.net/NGBTEAM/20250326155351635.png)
#### 作用
可以把多个构造方法中重复的代码抽取出来
#### 执行时机
创建本类对象的时候会先执行构造代码块在执行构造方法
#### 不用构造代码块，如何将重复的代码提取？
##### 方法一
由于构造代码块不够灵活，有一些构造方法不想执行构造代码块的中代码，这种方式没办法执行，所以现在会用别的技术实现这一功能

将重复的代码写在有参构造里面，如果无参构造需要使用到这些代码的时候，在无参构造里面调用有参构造，传入默认值
![image.png](https://pic.hibugs.net/NGBTEAM/20250326160147407.png)

##### 方法二
将重复代码封装成方法，需要用到的时候调方法
![image.png](https://pic.hibugs.net/NGBTEAM/20250326160255754.png)

### 静态代码块（重点，需要掌握）
**格式**：`static{}`
**特点**：需要通过static关键字修饰，随着类的加载而加载，并且自动触发、只执行一次
**使用场景**：在类加载的时候，做一些数据初始化的时候使用
#### 不适用静态代码块初始化加载信息的弊端
![image.png](https://pic.hibugs.net/NGBTEAM/20250326161145714.png)

上图这种方式也可以实现在系统运行初期往集合内存入用户的数据，但是会有一些弊端，当该方法被多次反复调用，他会生成多个ArrayList，并且会多次对用户数据进行载入，浪费性能；而如果使用静态代码块，只执行一次，那么就可以避免被反复调用的时候多次载入重复的用户信息
#Java/Java基础/面向对象 
# 为什么要有抽象方法？
类是可以继承的，父类中放的是一些共性的代码，子类继承之后他可以重写方法，也可以不重写，如果遇到有些方法子类需要重写，但是子类故意不重写，或者忘记重写，那你是没有办法的。为此就衍生出了抽象方法，你只需要将父类中的方法定义为抽象方法，那么子类继承之后必须对这个方法进行重写，不重写子类的代码就会报错。而抽象方法所在的类就是抽象类
# 抽象方法
将共性的行为（方法）抽取到父类之后。由于每一个子类执行的内容是不一样，所以父类中不能确定具体的方法体。该方法就可以定义为抽象方法
## 格式
`权限修饰符 abstract 返回值类型 方法名();`
**注意：**
# 抽象类
## 格式
`权限修饰符 abstract class 类名{}`
# 抽象类&抽象方法的注意事项
- 抽象类不能实例化
- 抽象类中不一定有抽象方法，但是有抽象方法的类一定是抽象类
- 可以有构造方法
	- 抽象类的构造方法是给子类创建对象使用构造方法的时候给属性赋值的
- 抽象类的子类
	- 要么重写抽象类中的所有抽象方法
	- 要么是抽象类
# 抽象类&抽象方法的意义
- 疑问：
	- 把子类中共性的内容抽取到父类之后
	- 由于方法体不确定，需要定义为抽象。子类使用时需要重写
	- 那么我不抽取到父类，直接在子类写不是更节约代码吗？

如果不将共性抽取到父类中，再将其抽象，每个子类中对于吃这个方法的定义可以是千奇百怪的，项目是合作开发的，每个人的想法都会不一样，有些人起名叫eat()有些人起名叫eating()有些人可能起名abc()，这样每个人调用不同的子类中的吃方法的时候都得去看源代码中是怎么写的，才能去调用，==这会让我们的代码不统一，之后在调用的时候会非常痛苦==
![image.png](https://pic.hibugs.net/NGBTEAM/20250327004340433.png)

如果将吃方法定义为抽象方法，那么子类继承的时候就必须要强制重写吃方法，并且要使用eat()这个方法名，这样调用者调用的时候只需要去父类中查看即可，也就是将代码格式进行统一
![image.png](https://pic.hibugs.net/NGBTEAM/20250327004732305.png)


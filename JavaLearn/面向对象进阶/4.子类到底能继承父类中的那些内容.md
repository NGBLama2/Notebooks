 #Java/Java基础/面向对象/继承 
# 关于继承的误区
误区1：父类私有的东西，子类就无法继承
误区2：父类中非私有的成员，就被子类继承下来

# 父类中能否被继承的模块
也就包含三块：构造方法、成员变量、成员方法
	- 统称为类的成员

|      | 非私有 | 私有private |
| ---- | --- | --------- |
| 构造方法 | 不能  | 不能        |
| 成员变量 | 能   | 能         |
| 成员方法 | 能   | 不能        |
## 构造方法是否可以被继承
==不能==

假设父类的构造方法能够被继承，那么子类继承了之后相当于把父类的构造方法直接拿过来，但是构造方法的名字和子类名不同，违背了规则，故是不被继承的
![image.png](https://pic.hibugs.net/NGBTEAM/20250315114608015.png)

## 成员变量是否可以被继承
==可以==

成员变量不管是私有的还是非私有的都可以被子类继承
	- 类中非私有的成员变量可以被直接使用
	- 类中私有的成员变量不能被直接使用，需要使用get、set方法
## 继承的内存图
### 非私有成员
1. 测试类TedstStudent的字节码加载到方法区当中
2. main方法被JVM调用，main方法进栈
3. 这时候需要创建Zi类型的对象，所以将Zi的字节码加载进入方法区，由于他有继承，所以也会把被继承的类的字节码文件加载进入方法区
4. z是变量名，Zi是用来限定，z变量后续是用来存放Zi类型的对象的地址
5. 需要new一个新的Zi，这时候会在堆中开辟一块空间，但是通往常的不一样，因为Zi类是有继承的，所以在堆中会有两块，一块用来存放Zi自己的东西，另一块用来存放从父类中继承来的东西
6. 当要修改对象的属性值时，会现在堆中的存放自己类东西的空间里进行查找，若没有则会去存放父类继承的东西的空间里进行查找
![image.png](https://pic.hibugs.net/NGBTEAM/20250315120535086.png)

然后打印输出后，main方法执行完毕就会出栈，出栈后栈中保存的main方法中声明的变量就会变成垃圾，会让Java自动回收
![image.png](https://pic.hibugs.net/NGBTEAM/20250315121735586.png)

方法里面的变量一旦消失，在方法里变量指向的在堆中的对象就会变成垃圾，这些垃圾也会有Java自动回收
### 私有成员
私有成员能被成功继承，但是不能直接使用
## 成员方法是否可以被继承
### 继承方法调用方式（虚方法表）
首先继承的方法调用并不是从子类开始一级一级往上找，如果真的是这样一旦当继承的层级越来越多的时候，JVM找方法的效率就会慢，Java运行代码的效率也会慢
![image.png](https://pic.hibugs.net/NGBTEAM/20250315123536042.png)

如果如上图所示A类要调用方法P，需要找15层，效率极低。所以为了解决这种很多层继承的关系，Java设计了虚方法表将一些常用的方法加入进去，以此加快方法的调用。

所有父类会把所有符合：
	- 非private
	- 非static
	- 非final
以上这些条件的方法加入到虚方法表中

![image.png](https://pic.hibugs.net/NGBTEAM/20250315123339882.png)
而B类继承C类的时候，会将C类的虚方法表也继承，并且在此基础上加上自己的常用的方法。
![image.png](https://pic.hibugs.net/NGBTEAM/20250315123831388.png)
当A再继承B的时候，就会将虚方法表继承，然后将自己常用的方法（符合条件的方法）放入虚方法表中
![image.png](https://pic.hibugs.net/NGBTEAM/20250315124051737.png)
综上，只有父类的虚方法才能被子类继承。如果虚方法表中没有记录那么JVM还是需要一层一层的往上找方法
### 继承内存图
1. 加载TestStudent字节码文件
2. main方法入栈
3. 发现需要加载Zi的字节码文件
4. 发现Zi继承了Fu，所以加载Fu的字节码文件
5. 所有的类都直接或间接的继承Object，Fu没有继承别的类，所以JVM自动帮他补充了继承Object类，所以把Object的字节码文件加载进方法去
6. Object他要将自己的虚方法添加进虚方法表中（一共有5个）
7. Fu继承Object，所以将Object的虚方法表继承，并且加入自己的虚方法
8. Zi继承Fu，所以将Fu的虚方法表继承，并且加入自己的虚方法，至此字节码文件加载完毕

![image.png](https://pic.hibugs.net/NGBTEAM/20250315124653101.png)

9. 调用ziShow()和fuShow2()的时候都会去虚方法表中找是不是虚方法，如果是直接调用

![image.png](https://pic.hibugs.net/NGBTEAM/20250315125337072.png)

10. 调用fuShow2()时，首先会查虚方法表，发现查找不到说明该方法不是虚方法，就会从子类字节码文件中的所有成员方法开始，一级一级往上查找
11. 当他找到Fu类中的时候发现他是一个私有方法（private）然后就会报错

![image.png](https://pic.hibugs.net/NGBTEAM/20250315125736057.png)


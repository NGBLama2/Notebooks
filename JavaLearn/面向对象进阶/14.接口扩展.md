#Java/Java基础/面向对象/接口 
# JDK8开始接口中新增的方法
JDK7以前：接口中只能定义抽象方法
JDK8的新特性：接口中可以定义有方法体的方法（默认、静态）
JDK9的新特性：接口中可以定义私有方法
## 新增的原因
定义好一个规则（接口）之后，大家都按照这个规则去编写代码，没问题，但是当代码要更新的时候，新增了规则，这时候所有人都需要去修改自己的代码，将新增的规则重写，否则代码就会报错。这样对于代码的维护来说难度就高了很多

所以为了解决上述的问题，JDK8开始就新增了特性：接口中可以定义有方法体的方法。这样当这个接口新增了十个方法，其他实现的类只需要在需要的时候重写方法即可
## JDK8接口新增方法
### 默认方法
允许在接口中定义默认方法，需要使用关键字default修饰
	- 作用：解决接口升级的问题
#### 定义格式
格式：`public default 返回值类型 方法名(参数列表){}`
范例：`public default void show(){}`
##### 注意事项
- 默认方法不是抽象方法，不强制被重写。但如果被重写，重写的时候要去掉default
- public可以省略，default不能省略
- 如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写
### 静态方法
允许在接口中定义定义静态方法，需要用static修饰
#### 定义格式
格式：`public static 返回值类型 方法名(参数列表)`
范例：`public static void show(){}`
#### 注意事项
- 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用
- public可以省略，static不能省略
## JDK9新增的方法
在接口中，可能会有一些方法中又重复的代码，我们通常会将重复的代码提取出来变成一个方法，然后再需要用到该功能的地方，调用该方法，以此来让代码简洁，减少重复代码，但是这些重复代码往往就是在一个接口中去使用，而外类不会也没必要去调用，所以JDK9中就新增了private修饰方法，这样就可以让这些方法只能在该接口中被调用
### 私有方法的定义格式
格式1：`private 返回值类型 方法名(参数列表){}`
	- 给默认方法服务的
格式2：`private static 返回值类型 方法名(参数列表)`
	- 给静态方法服务的
# 接口的应用
## 接口的多态
当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方式称为接口多态
	例：
```
// 吃接口
public interface Eat{
	...
}

public class Student implements Eat{
	...
}

public class Teacher implements Eat{
	...
}
=================以下是测试类===================
public class Test{
	public void method(Eat e){
		...
	}
}

// 形参为Eat a，可以传入Student的对象也可以传入Teacher的对象（接口的多态）
```
![image.png](https://pic.hibugs.net/NGBTEAM/20250329172926153.png)

`接口类型 j = new 实现类对象();`也遵守编译看左边，运行看右边的原则
# 适配器设计模式
设计模式就是解决各种问题的套路

**适配器设计模式：解决接口与接口实现类之间的矛盾问题**

当我们需要去实现某一个接口，但只需要用到接口中的某一个或者几个方法的时候，我们不能选择性的重写需要的方法，对所有抽象的方法必须全部重写，这样子对于代码的阅读性会变差，也会使得代码变得臃肿。

下图中我们只想使用method5，但是实现了Inter接口之后，就必须将method1-10全部重写

![image.png](https://pic.hibugs.net/NGBTEAM/20250329174928552.png)

为了解决上述的问题，我们一般就会新建一个类，实现这个接口，然后对这个接口中的所有抽象方法进行**空实现**
	- 空实现的意思就是重写，但是方法体内不写任何东西
![image.png](https://pic.hibugs.net/NGBTEAM/20250329175136208.png)

紧接着在创建一个类不去实现接口，而是继承这个空实现了的类，这样我们只需要将我们需要的方法重写即可
![image.png](https://pic.hibugs.net/NGBTEAM/20250329175200158.png)

代码就变得简洁了。这个处于中间的对接口进行空实现的类就叫做适配器，这个适配器我们对接口的所有抽象方法进行了空实现，那么他本身也是无意义的，所以我们也不希望外界去创建这个适配器的类，所以应该将该适配器定义为抽象类
![image.png](https://pic.hibugs.net/NGBTEAM/20250329175333828.png)
### 书写步骤
1. 编写中间类XXXAdapter，实现对应的接口对接口中的抽象方法进行空实现
2. 让真正的实现类继承中间类，并重写需要使用的方法
3. 为了避免其他类创建中间适配器的对象，中间的适配器类用`abstract`进行修饰
**注意：如果真正的实现类有父类，可以让中间适配器先去继承父类，然后真正的实现类再继承中间适配器**